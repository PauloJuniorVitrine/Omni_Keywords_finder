"""
Exemplo de Uso do Sistema ML Adaptativo - Omni Keywords Finder
Tracing ID: ML_EXAMPLE_20241219_001
Data: 2024-12-19
Vers√£o: 1.0

Demonstra como usar o sistema ML adaptativo para:
- Clustering adaptativo de keywords
- Otimiza√ß√£o autom√°tica de par√¢metros
- Feedback loop para aprendizado cont√≠nuo
- Sugest√µes inteligentes
"""

import sys
import os
import time
from typing import List, Dict, Any
from datetime import datetime

# Adicionar o diret√≥rio raiz ao path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Importar sistema ML adaptativo
from infrastructure.ml.adaptativo.modelo_adaptativo import (
    AdaptiveModel, ModelConfig, ModelType, get_adaptive_model
)
from infrastructure.ml.adaptativo.otimizador import (
    AutoOptimizer, OptimizationConfig, OptimizationAlgorithm, get_auto_optimizer
)
from infrastructure.ml.adaptativo.feedback_loop import (
    FeedbackLoop, FeedbackLoopConfig, FeedbackData, FeedbackType, get_feedback_loop
)


def create_sample_keywords_data() -> List[Dict[str, Any]]:
    """Cria dados de exemplo para demonstra√ß√£o."""
    keywords = [
        "marketing digital",
        "seo otimiza√ß√£o",
        "google ads",
        "facebook ads",
        "instagram marketing",
        "linkedin ads",
        "email marketing",
        "content marketing",
        "inbound marketing",
        "social media marketing",
        "ppc campaigns",
        "google analytics",
        "conversion optimization",
        "landing page design",
        "copywriting",
        "brand strategy",
        "market research",
        "customer journey",
        "lead generation",
        "sales funnel",
        "crm software",
        "automation tools",
        "web design",
        "mobile marketing",
        "video marketing",
        "podcast marketing",
        "influencer marketing",
        "affiliate marketing",
        "retargeting ads",
        "display advertising"
    ]
    
    # Criar dados estruturados com m√©tricas
    keywords_data = []
    for index, keyword in enumerate(keywords):
        keywords_data.append({
            "keyword": keyword,
            "score": 70 + (index % 30),  # Score variado
            "volume_busca": 1000 + (index * 100),
            "cpc": 1.5 + (index * 0.1),
            "concorrencia": 0.3 + (index * 0.02),
            "categoria": "marketing" if "marketing" in keyword else "tecnologia",
            "intencao": "comercial" if "ads" in keyword else "informacional"
        })
    
    return keywords_data


def demonstrate_adaptive_clustering():
    """Demonstra clustering adaptativo."""
    print("üîç **DEMONSTRA√á√ÉO: CLUSTERING ADAPTATIVO**")
    print("=" * 50)
    
    # Criar dados de exemplo
    keywords_data = create_sample_keywords_data()
    print(f"üìä Keywords para clustering: {len(keywords_data)}")
    
    # Configurar modelo adaptativo
    config = ModelConfig(
        model_type=ModelType.KMEANS,
        optimization_strategy="bayesian_optimization",
        n_trials=20,  # Poucos trials para demonstra√ß√£o r√°pida
        min_clusters=3,
        max_clusters=8,
        auto_feature_selection=True
    )
    
    # Inicializar modelo
    model = AdaptiveModel(config)
    
    # Executar clustering
    print("üîÑ Executando clustering adaptativo...")
    start_time = time.time()
    
    keywords_text = [item["keyword"] for item in keywords_data]
    optimization_result = model.fit(keywords_text)
    
    clustering_time = time.time() - start_time
    
    # Obter clusters
    cluster_labels = model.predict(keywords_text)
    
    # Organizar resultados
    clusters = {}
    for index, (keyword_data, label) in enumerate(zip(keywords_data, cluster_labels)):
        if label not in clusters:
            clusters[label] = []
        clusters[label].append(keyword_data["keyword"])
    
    # Exibir resultados
    print(f"‚úÖ Clustering conclu√≠do em {clustering_time:.2f}string_data")
    print(f"üéØ Performance score: {optimization_result.best_score:.4f}")
    print(f"üìà N√∫mero de clusters: {len(clusters)}")
    print(f"üîß Melhores par√¢metros: {optimization_result.best_params}")
    
    print("\nüìã **CLUSTERS GERADOS:**")
    for cluster_id, keywords in clusters.items():
        print(f"\nüî∏ Cluster {cluster_id} ({len(keywords)} keywords):")
        for keyword in keywords[:5]:  # Mostrar apenas os primeiros 5
            print(f"   ‚Ä¢ {keyword}")
        if len(keywords) > 5:
            print(f"   ... e mais {len(keywords) - 5} keywords")
    
    return model, clusters


def demonstrate_auto_optimization():
    """Demonstra otimiza√ß√£o autom√°tica."""
    print("\n‚ö° **DEMONSTRA√á√ÉO: OTIMIZA√á√ÉO AUTOM√ÅTICA**")
    print("=" * 50)
    
    # Configurar otimizador
    config = OptimizationConfig(
        algorithm=OptimizationAlgorithm.TPE,
        n_trials=15,  # Poucos trials para demonstra√ß√£o
        timeout=300,  # 5 minutos
        early_stopping=True,
        patience=5
    )
    
    # Inicializar otimizador
    optimizer = AutoOptimizer(config)
    
    # Definir limites dos par√¢metros
    from sklearn.cluster import KMeans
    parameter_bounds = {
        'n_clusters': ('int', 2, 10),
        'max_iter': ('int', 100, 500),
        'n_init': ('int', 5, 15)
    }
    
    optimizer.set_parameter_bounds(parameter_bounds)
    
    # Criar dados de exemplo
    import numpy as np
    X = np.random.rand(100, 5)  # 100 amostras, 5 features
    
    # Executar otimiza√ß√£o
    print("üîÑ Executando otimiza√ß√£o autom√°tica...")
    start_time = time.time()
    
    result = optimizer.optimize(X, KMeans)
    
    optimization_time = time.time() - start_time
    
    # Exibir resultados
    print(f"‚úÖ Otimiza√ß√£o conclu√≠da em {optimization_time:.2f}string_data")
    print(f"üéØ Melhor score: {result.best_score:.4f}")
    print(f"üîß Melhores par√¢metros: {result.best_params}")
    print(f"üìä N√∫mero de tentativas: {result.n_trials}")
    
    return optimizer, result


def demonstrate_feedback_loop():
    """Demonstra feedback loop."""
    print("\nüîÑ **DEMONSTRA√á√ÉO: FEEDBACK LOOP**")
    print("=" * 50)
    
    # Configurar feedback loop
    config = FeedbackLoopConfig(
        feedback_window_size=100,
        drift_detection_threshold=0.1,
        retraining_threshold=0.15,
        enable_automatic_retraining=True
    )
    
    # Inicializar feedback loop
    feedback_loop = FeedbackLoop(config)
    
    # Simular feedback de usu√°rios
    print("üìù Simulando feedback de usu√°rios...")
    
    feedback_types = [
        FeedbackType.USER_RATING,
        FeedbackType.CLICK_THROUGH_RATE,
        FeedbackType.CONVERSION_RATE,
        FeedbackType.DWELL_TIME
    ]
    
    for index in range(20):
        feedback_type = feedback_types[index % len(feedback_types)]
        value = 0.3 + (index * 0.03)  # Valores crescentes
        user_id = f"user_{index % 5}"
        
        feedback = FeedbackData(
            feedback_type=feedback_type,
            value=value,
            timestamp=time.time() - (index * 3600),  # Timestamps decrescentes
            user_id=user_id,
            metadata={"cluster_id": f"cluster_{index % 3}"}
        )
        
        feedback_loop.add_feedback(feedback)
    
    # Aguardar processamento
    time.sleep(2)
    
    # Obter resumo
    summary = feedback_loop.get_feedback_summary()
    
    print("‚úÖ Feedback processado!")
    print(f"üìä Total de feedbacks: {summary.get('total_feedback', 0)}")
    print(f"üìà Performance m√©dia: {summary.get('average_performance', 0):.3f}")
    print(f"üîÑ Drift detectado: {summary.get('drift_detected', False)}")
    
    if summary.get('drift_detected'):
        print(f"‚ö†Ô∏è Severidade do drift: {summary.get('drift_severity', 0):.3f}")
    
    return feedback_loop, summary


def demonstrate_integration():
    """Demonstra integra√ß√£o completa."""
    print("\nüöÄ **DEMONSTRA√á√ÉO: INTEGRA√á√ÉO COMPLETA**")
    print("=" * 50)
    
    # Criar dados de exemplo
    keywords_data = create_sample_keywords_data()
    
    # 1. Clustering adaptativo
    print("1Ô∏è‚É£ Executando clustering adaptativo...")
    model, clusters = demonstrate_adaptive_clustering()
    
    # 2. Otimiza√ß√£o autom√°tica
    print("\n2Ô∏è‚É£ Executando otimiza√ß√£o autom√°tica...")
    optimizer, opt_result = demonstrate_auto_optimization()
    
    # 3. Feedback loop
    print("\n3Ô∏è‚É£ Executando feedback loop...")
    feedback_loop, feedback_summary = demonstrate_feedback_loop()
    
    # 4. Sugest√µes inteligentes
    print("\n4Ô∏è‚É£ Gerando sugest√µes inteligentes...")
    
    # Simular predi√ß√µes
    keywords_text = [item["keyword"] for item in keywords_data[:10]]
    cluster_labels = model.predict(keywords_text)
    
    suggestions = []
    for index, (keyword_data, label) in enumerate(zip(keywords_data[:10], cluster_labels)):
        cluster_score = 0.5 + (label * 0.1)
        final_score = keyword_data["score"] * 0.7 + cluster_score * 0.3
        
        suggestions.append({
            "keyword": keyword_data["keyword"],
            "original_score": keyword_data["score"],
            "cluster_score": cluster_score,
            "final_score": final_score,
            "cluster": label
        })
    
    # Ordenar por score final
    suggestions.sort(key=lambda value: value["final_score"], reverse=True)
    
    print("‚úÖ Sugest√µes geradas!")
    print("\nüèÜ **TOP 5 SUGEST√ïES:**")
    for index, suggestion in enumerate(suggestions[:5]):
        print(f"{index+1}. {suggestion['keyword']}")
        print(f"   Score original: {suggestion['original_score']:.1f}")
        print(f"   Score cluster: {suggestion['cluster_score']:.3f}")
        print(f"   Score final: {suggestion['final_score']:.1f}")
        print(f"   Cluster: {suggestion['cluster']}")
        print()
    
    # 5. Resumo final
    print("üìä **RESUMO DA INTEGRA√á√ÉO:**")
    print(f"‚úÖ Clustering: {len(clusters)} clusters gerados")
    print(f"‚úÖ Otimiza√ß√£o: Score {opt_result.best_score:.4f}")
    print(f"‚úÖ Feedback: {feedback_summary.get('total_feedback', 0)} feedbacks processados")
    print(f"‚úÖ Sugest√µes: {len(suggestions)} keywords analisadas")
    
    return {
        "model": model,
        "optimizer": optimizer,
        "feedback_loop": feedback_loop,
        "clusters": clusters,
        "suggestions": suggestions
    }


def main():
    """Fun√ß√£o principal de demonstra√ß√£o."""
    print("ü§ñ **SISTEMA ML ADAPTATIVO - OMNƒ∞ KEYWORDS FINDER**")
    print("=" * 60)
    print(f"üìÖ Data/Hora: {datetime.now().strftime('%Y-%m-%data %H:%M:%S')}")
    print(f"üÜî Tracing ID: ML_EXAMPLE_20241219_001")
    print("=" * 60)
    
    try:
        # Executar demonstra√ß√£o completa
        results = demonstrate_integration()
        
        print("\nüéâ **DEMONSTRA√á√ÉO CONCLU√çDA COM SUCESSO!**")
        print("=" * 60)
        print("‚úÖ Sistema ML adaptativo funcionando perfeitamente")
        print("‚úÖ Clustering adaptativo implementado")
        print("‚úÖ Otimiza√ß√£o autom√°tica ativa")
        print("‚úÖ Feedback loop operacional")
        print("‚úÖ Sugest√µes inteligentes geradas")
        print("=" * 60)
        
        return results
        
    except Exception as e:
        print(f"\n‚ùå **ERRO NA DEMONSTRA√á√ÉO:** {str(e)}")
        print("üîß Verifique se todas as depend√™ncias est√£o instaladas")
        return None


if __name__ == "__main__":
    main() 