"""
游댃 Canary Endpoints System - Omni Keywords Finder

Sistema de endpoints can치rio para shadow testing e detec칞칚o de regress칫es.

Tracing ID: canary-endpoints-system-2025-01-27-001
"""

import asyncio
import json
import logging
import time
from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, Dict, List, Optional, Callable
from urllib.parse import urlparse

import aiohttp
import pytest
from dataclasses_json import dataclass_json

from tests.utils.risk_calculator import calculate_risk_score
from tests.utils.semantic_validator import SemanticValidator
from tests.decorators.critical_decorators import (
    critical_risk, 
    semantic_validation, 
    real_data_validation,
    production_scenario,
    side_effects_monitoring,
    performance_monitoring
)

# Configura칞칚o de logging estruturado
logger = logging.getLogger(__name__)

@dataclass_json
@dataclass
class CanaryEndpoint:
    """Representa um endpoint can치rio"""
    path: str
    method: str
    production_url: str
    canary_url: str
    traffic_percentage: float = 0.1  # 10% do tr치fego vai para can치rio
    health_check_path: Optional[str] = None
    rollback_threshold: float = 0.05  # 5% de erro para rollback
    enabled: bool = True
    created_at: float = field(default_factory=time.time)

@dataclass_json
@dataclass
class CanaryHealth:
    """Status de sa칰de do endpoint can치rio"""
    endpoint_path: str
    is_healthy: bool
    response_time: float
    error_rate: float
    success_count: int
    error_count: int
    last_check: float = field(default_factory=time.time)
    risk_score: int = 0

@dataclass_json
@dataclass
class CanaryTrafficSplit:
    """Configura칞칚o de divis칚o de tr치fego"""
    endpoint_path: str
    production_weight: float
    canary_weight: float
    total_requests: int
    canary_requests: int
    production_requests: int
    last_updated: float = field(default_factory=time.time)

class CanaryEndpointsManager:
    """
    Gerenciador de endpoints can치rio
    
    Caracter칤sticas:
    - Configura칞칚o de endpoints can치rio
    - Health checks autom치ticos
    - Divis칚o de tr치fego inteligente
    - Rollback autom치tico
    - M칠tricas de performance
    """
    
    def __init__(self, 
                 base_production_url: str,
                 base_canary_url: str,
                 health_check_interval: int = 30):
        """
        Inicializa o gerenciador de endpoints can치rio
        
        Args:
            base_production_url: URL base da produ칞칚o
            base_canary_url: URL base do can치rio
            health_check_interval: Intervalo de health checks em segundos
        """
        self.base_production_url = base_production_url.rstrip('/')
        self.base_canary_url = base_canary_url.rstrip('/')
        self.health_check_interval = health_check_interval
        
        self.endpoints: Dict[str, CanaryEndpoint] = {}
        self.health_status: Dict[str, CanaryHealth] = {}
        self.traffic_splits: Dict[str, CanaryTrafficSplit] = {}
        
        self.semantic_validator = SemanticValidator()
        self.logger = logging.getLogger(f"{__name__}.CanaryManager")
        
        # M칠tricas de performance
        self.performance_metrics = {
            'total_endpoints': 0,
            'healthy_endpoints': 0,
            'unhealthy_endpoints': 0,
            'total_requests': 0,
            'canary_requests': 0,
            'production_requests': 0,
            'rollbacks_triggered': 0
        }
    
    def register_endpoint(self, endpoint: CanaryEndpoint) -> None:
        """
        Registra um novo endpoint can치rio
        
        Args:
            endpoint: Configura칞칚o do endpoint
        """
        endpoint_key = f"{endpoint.method}:{endpoint.path}"
        
        if endpoint_key in self.endpoints:
            self.logger.warning(f"Endpoint {endpoint_key} j치 registrado, atualizando...")
        
        self.endpoints[endpoint_key] = endpoint
        
        # Inicializa health status
        self.health_status[endpoint_key] = CanaryHealth(
            endpoint_path=endpoint.path,
            is_healthy=True,
            response_time=0.0,
            error_rate=0.0,
            success_count=0,
            error_count=0
        )
        
        # Inicializa traffic split
        self.traffic_splits[endpoint_key] = CanaryTrafficSplit(
            endpoint_path=endpoint.path,
            production_weight=1.0 - endpoint.traffic_percentage,
            canary_weight=endpoint.traffic_percentage,
            total_requests=0,
            canary_requests=0,
            production_requests=0
        )
        
        self.performance_metrics['total_endpoints'] += 1
        self.logger.info(f"Endpoint can치rio registrado: {endpoint_key}")
    
    async def route_request(self, 
                          method: str, 
                          path: str, 
                          headers: Dict[str, str], 
                          body: Optional[str] = None) -> Dict[str, Any]:
        """
        Roteia uma requisi칞칚o para produ칞칚o ou can치rio
        
        Args:
            method: M칠todo HTTP
            path: Caminho da requisi칞칚o
            headers: Headers da requisi칞칚o
            body: Corpo da requisi칞칚o
            
        Returns:
            Resposta da requisi칞칚o
        """
        endpoint_key = f"{method}:{path}"
        
        if endpoint_key not in self.endpoints:
            # Se n칚o 칠 um endpoint can치rio, vai direto para produ칞칚o
            return await self._make_production_request(method, path, headers, body)
        
        endpoint = self.endpoints[endpoint_key]
        if not endpoint.enabled:
            return await self._make_production_request(method, path, headers, body)
        
        # Verifica sa칰de do can치rio
        health = self.health_status[endpoint_key]
        if not health.is_healthy:
            self.logger.warning(f"Can치rio n칚o saud치vel para {endpoint_key}, usando produ칞칚o")
            return await self._make_production_request(method, path, headers, body)
        
        # Decide roteamento baseado em peso do tr치fego
        traffic_split = self.traffic_splits[endpoint_key]
        import random
        rand_val = random.random()
        
        if rand_val < traffic_split.canary_weight:
            # Rota para can치rio
            traffic_split.canary_requests += 1
            self.performance_metrics['canary_requests'] += 1
            response = await self._make_canary_request(method, path, headers, body)
        else:
            # Rota para produ칞칚o
            traffic_split.production_requests += 1
            self.performance_metrics['production_requests'] += 1
            response = await self._make_production_request(method, path, headers, body)
        
        traffic_split.total_requests += 1
        self.performance_metrics['total_requests'] += 1
        traffic_split.last_updated = time.time()
        
        return response
    
    async def _make_production_request(self, 
                                     method: str, 
                                     path: str, 
                                     headers: Dict[str, str], 
                                     body: Optional[str] = None) -> Dict[str, Any]:
        """Faz requisi칞칚o para produ칞칚o"""
        url = f"{self.base_production_url}{path}"
        
        async with aiohttp.ClientSession() as session:
            start_time = time.time()
            try:
                async with session.request(
                    method=method,
                    url=url,
                    headers=headers,
                    data=body,
                    timeout=aiohttp.ClientTimeout(total=30)
                ) as response:
                    response_body = await response.text()
                    response_time = time.time() - start_time
                    
                    return {
                        "status_code": response.status,
                        "headers": dict(response.headers),
                        "body": response_body,
                        "response_time": response_time,
                        "source": "production"
                    }
            except Exception as e:
                response_time = time.time() - start_time
                self.logger.error(f"Erro na requisi칞칚o de produ칞칚o: {e}")
                
                return {
                    "status_code": 500,
                    "headers": {},
                    "body": str(e),
                    "response_time": response_time,
                    "source": "production"
                }
    
    async def _make_canary_request(self, 
                                 method: str, 
                                 path: str, 
                                 headers: Dict[str, str], 
                                 body: Optional[str] = None) -> Dict[str, Any]:
        """Faz requisi칞칚o para can치rio"""
        url = f"{self.base_canary_url}{path}"
        
        async with aiohttp.ClientSession() as session:
            start_time = time.time()
            try:
                async with session.request(
                    method=method,
                    url=url,
                    headers=headers,
                    data=body,
                    timeout=aiohttp.ClientTimeout(total=30)
                ) as response:
                    response_body = await response.text()
                    response_time = time.time() - start_time
                    
                    return {
                        "status_code": response.status,
                        "headers": dict(response.headers),
                        "body": response_body,
                        "response_time": response_time,
                        "source": "canary"
                    }
            except Exception as e:
                response_time = time.time() - start_time
                self.logger.error(f"Erro na requisi칞칚o de can치rio: {e}")
                
                return {
                    "status_code": 500,
                    "headers": {},
                    "body": str(e),
                    "response_time": response_time,
                    "source": "canary"
                }
    
    async def perform_health_check(self, endpoint_key: str) -> CanaryHealth:
        """
        Executa health check em um endpoint can치rio
        
        Args:
            endpoint_key: Chave do endpoint
            
        Returns:
            Status de sa칰de atualizado
        """
        if endpoint_key not in self.endpoints:
            raise ValueError(f"Endpoint {endpoint_key} n칚o encontrado")
        
        endpoint = self.endpoints[endpoint_key]
        health = self.health_status[endpoint_key]
        
        # Faz health check
        health_check_path = endpoint.health_check_path or f"{endpoint.path}/health"
        
        try:
            response = await self._make_canary_request(
                "GET", health_check_path, {"Content-Type": "application/json"}
            )
            
            # Atualiza m칠tricas de sa칰de
            is_healthy = response["status_code"] == 200
            response_time = response["response_time"]
            
            if is_healthy:
                health.success_count += 1
            else:
                health.error_count += 1
            
            total_requests = health.success_count + health.error_count
            error_rate = health.error_count / max(total_requests, 1)
            
            # Atualiza health status
            health.is_healthy = is_healthy and error_rate < endpoint.rollback_threshold
            health.response_time = response_time
            health.error_rate = error_rate
            health.last_check = time.time()
            
            # Calcula RISK_SCORE
            health.risk_score = calculate_risk_score(
                component="canary_health_check",
                operation=f"health_check_{endpoint.path}",
                data_sensitivity="low",
                external_dependencies=1,
                error_rate=error_rate
            )
            
            # Atualiza m칠tricas globais
            if health.is_healthy:
                self.performance_metrics['healthy_endpoints'] = sum(
                    1 for h in self.health_status.values() if h.is_healthy
                )
                self.performance_metrics['unhealthy_endpoints'] = (
                    self.performance_metrics['total_endpoints'] - 
                    self.performance_metrics['healthy_endpoints']
                )
            
            # Log estruturado
            health_log = {
                "event": "canary_health_check",
                "endpoint": endpoint_key,
                "is_healthy": health.is_healthy,
                "error_rate": error_rate,
                "response_time": response_time,
                "risk_score": health.risk_score,
                "timestamp": datetime.utcnow().isoformat()
            }
            
            if health.is_healthy:
                self.logger.info(f"HEALTH_CHECK_LOG: {json.dumps(health_log)}")
            else:
                self.logger.error(f"HEALTH_CHECK_LOG: {json.dumps(health_log)}")
            
            return health
            
        except Exception as e:
            self.logger.error(f"Erro no health check de {endpoint_key}: {e}")
            
            # Marca como n칚o saud치vel
            health.is_healthy = False
            health.error_count += 1
            health.last_check = time.time()
            health.risk_score = calculate_risk_score(
                component="canary_health_check",
                operation=f"health_check_{endpoint.path}",
                data_sensitivity="low",
                external_dependencies=1,
                error_rate=1.0
            )
            
            return health
    
    async def trigger_rollback(self, endpoint_key: str) -> bool:
        """
        Dispara rollback de um endpoint can치rio
        
        Args:
            endpoint_key: Chave do endpoint
            
        Returns:
            True se rollback foi executado com sucesso
        """
        if endpoint_key not in self.endpoints:
            return False
        
        endpoint = self.endpoints[endpoint_key]
        endpoint.enabled = False
        
        self.performance_metrics['rollbacks_triggered'] += 1
        
        # Log estruturado
        rollback_log = {
            "event": "canary_rollback",
            "endpoint": endpoint_key,
            "timestamp": datetime.utcnow().isoformat(),
            "reason": "health_check_failed",
            "risk_score": self.health_status[endpoint_key].risk_score
        }
        
        self.logger.error(f"ROLLBACK_LOG: {json.dumps(rollback_log)}")
        
        return True
    
    def get_performance_report(self) -> Dict[str, Any]:
        """Gera relat칩rio de performance dos endpoints can치rio"""
        return {
            "timestamp": datetime.utcnow().isoformat(),
            "total_endpoints": self.performance_metrics['total_endpoints'],
            "healthy_endpoints": self.performance_metrics['healthy_endpoints'],
            "unhealthy_endpoints": self.performance_metrics['unhealthy_endpoints'],
            "total_requests": self.performance_metrics['total_requests'],
            "canary_requests": self.performance_metrics['canary_requests'],
            "production_requests": self.performance_metrics['production_requests'],
            "rollbacks_triggered": self.performance_metrics['rollbacks_triggered'],
            "canary_traffic_percentage": (
                self.performance_metrics['canary_requests'] / 
                max(self.performance_metrics['total_requests'], 1) * 100
            ),
            "endpoints_health": [
                {
                    "endpoint": key,
                    "is_healthy": health.is_healthy,
                    "error_rate": health.error_rate,
                    "response_time": health.response_time,
                    "risk_score": health.risk_score,
                    "last_check": datetime.fromtimestamp(health.last_check).isoformat()
                }
                for key, health in self.health_status.items()
            ],
            "traffic_splits": [
                {
                    "endpoint": key,
                    "canary_weight": split.canary_weight,
                    "production_weight": split.production_weight,
                    "total_requests": split.total_requests,
                    "canary_requests": split.canary_requests,
                    "production_requests": split.production_requests
                }
                for key, split in self.traffic_splits.items()
            ]
        }

# Decorators para testes de endpoints can치rio
@critical_risk
@semantic_validation
@real_data_validation
@production_scenario
@side_effects_monitoring
@performance_monitoring
class TestCanaryEndpoints:
    """Testes de integra칞칚o para endpoints can치rio"""
    
    @pytest.fixture
    def canary_manager(self):
        """Fixture para o gerenciador de endpoints can치rio"""
        return CanaryEndpointsManager(
            base_production_url="https://api.omni-keywords-finder.com",
            base_canary_url="https://canary.omni-keywords-finder.com",
            health_check_interval=30
        )
    
    def test_canary_endpoint_registration(self, canary_manager):
        """
        Testa o registro de endpoints can치rio
        
        RISK_SCORE: 70 (Alto - Configura칞칚o de produ칞칚o)
        """
        # Registra endpoint can치rio
        endpoint = CanaryEndpoint(
            path="/api/v1/keywords/instagram/search",
            method="GET",
            production_url="https://api.omni-keywords-finder.com/api/v1/keywords/instagram/search",
            canary_url="https://canary.omni-keywords-finder.com/api/v1/keywords/instagram/search",
            traffic_percentage=0.1,
            health_check_path="/api/v1/keywords/instagram/search/health",
            rollback_threshold=0.05
        )
        
        canary_manager.register_endpoint(endpoint)
        
        # Valida칞칫es
        endpoint_key = f"{endpoint.method}:{endpoint.path}"
        assert endpoint_key in canary_manager.endpoints
        assert endpoint_key in canary_manager.health_status
        assert endpoint_key in canary_manager.traffic_splits
        
        # Valida configura칞칫es
        registered_endpoint = canary_manager.endpoints[endpoint_key]
        assert registered_endpoint.path == endpoint.path
        assert registered_endpoint.method == endpoint.method
        assert registered_endpoint.traffic_percentage == 0.1
        assert registered_endpoint.rollback_threshold == 0.05
        
        # Log estruturado
        logger.info(f"Canary endpoint registration test completed: {endpoint_key}")
        logger.info(f"Total endpoints: {canary_manager.performance_metrics['total_endpoints']}")
    
    @pytest.mark.asyncio
    async def test_canary_health_check(self, canary_manager):
        """
        Testa health check de endpoints can치rio
        
        RISK_SCORE: 80 (Alto - Valida칞칚o de sa칰de)
        """
        # Registra endpoint para teste
        endpoint = CanaryEndpoint(
            path="/api/v1/keywords/facebook/analyze",
            method="POST",
            production_url="https://api.omni-keywords-finder.com/api/v1/keywords/facebook/analyze",
            canary_url="https://canary.omni-keywords-finder.com/api/v1/keywords/facebook/analyze",
            traffic_percentage=0.05,
            health_check_path="/api/v1/keywords/facebook/analyze/health"
        )
        
        canary_manager.register_endpoint(endpoint)
        endpoint_key = f"{endpoint.method}:{endpoint.path}"
        
        # Executa health check
        health = await canary_manager.perform_health_check(endpoint_key)
        
        # Valida칞칫es
        assert health is not None
        assert health.endpoint_path == endpoint.path
        assert isinstance(health.is_healthy, bool)
        assert isinstance(health.response_time, float)
        assert isinstance(health.error_rate, float)
        assert health.risk_score >= 70  # Teste cr칤tico
        
        # Log estruturado
        logger.info(f"Canary health check test completed: {endpoint_key}")
        logger.info(f"Health status: {health.is_healthy}")
        logger.info(f"Error rate: {health.error_rate}")
        logger.info(f"Risk score: {health.risk_score}")
    
    @pytest.mark.asyncio
    async def test_canary_request_routing(self, canary_manager):
        """
        Testa o roteamento de requisi칞칫es para can치rio
        
        RISK_SCORE: 85 (Alto - Roteamento de produ칞칚o)
        """
        # Registra endpoint para teste
        endpoint = CanaryEndpoint(
            path="/api/v1/keywords/youtube/search",
            method="GET",
            production_url="https://api.omni-keywords-finder.com/api/v1/keywords/youtube/search",
            canary_url="https://canary.omni-keywords-finder.com/api/v1/keywords/youtube/search",
            traffic_percentage=0.2
        )
        
        canary_manager.register_endpoint(endpoint)
        
        # Faz requisi칞칚o
        response = await canary_manager.route_request(
            method="GET",
            path="/api/v1/keywords/youtube/search",
            headers={"Authorization": "Bearer test_token"},
            body=None
        )
        
        # Valida칞칫es
        assert response is not None
        assert "status_code" in response
        assert "source" in response
        assert "response_time" in response
        assert response["source"] in ["production", "canary"]
        
        # Log estruturado
        logger.info(f"Canary request routing test completed")
        logger.info(f"Response source: {response['source']}")
        logger.info(f"Response time: {response['response_time']}")
        logger.info(f"Status code: {response['status_code']}")
    
    def test_canary_performance_metrics(self, canary_manager):
        """
        Testa as m칠tricas de performance dos endpoints can치rio
        
        RISK_SCORE: 75 (Alto - Valida칞칚o de m칠tricas)
        """
        # Registra alguns endpoints para teste
        endpoints = [
            CanaryEndpoint(
                path="/api/v1/keywords/tiktok/search",
                method="GET",
                production_url="https://api.omni-keywords-finder.com/api/v1/keywords/tiktok/search",
                canary_url="https://canary.omni-keywords-finder.com/api/v1/keywords/tiktok/search",
                traffic_percentage=0.15
            ),
            CanaryEndpoint(
                path="/api/v1/keywords/pinterest/analyze",
                method="POST",
                production_url="https://api.omni-keywords-finder.com/api/v1/keywords/pinterest/analyze",
                canary_url="https://canary.omni-keywords-finder.com/api/v1/keywords/pinterest/analyze",
                traffic_percentage=0.1
            )
        ]
        
        for endpoint in endpoints:
            canary_manager.register_endpoint(endpoint)
        
        # Gera relat칩rio de performance
        report = canary_manager.get_performance_report()
        
        # Valida칞칫es
        assert "timestamp" in report
        assert "total_endpoints" in report
        assert "healthy_endpoints" in report
        assert "unhealthy_endpoints" in report
        assert "total_requests" in report
        assert "canary_requests" in report
        assert "production_requests" in report
        assert "rollbacks_triggered" in report
        assert "canary_traffic_percentage" in report
        assert "endpoints_health" in report
        assert "traffic_splits" in report
        
        # Valida tipos de dados
        assert isinstance(report["total_endpoints"], int)
        assert isinstance(report["canary_traffic_percentage"], float)
        assert isinstance(report["endpoints_health"], list)
        assert isinstance(report["traffic_splits"], list)
        
        # Log estruturado
        logger.info(f"Canary performance metrics test completed")
        logger.info(f"Total endpoints: {report['total_endpoints']}")
        logger.info(f"Canary traffic percentage: {report['canary_traffic_percentage']}%")
        logger.info(f"Healthy endpoints: {report['healthy_endpoints']}")

if __name__ == "__main__":
    # Execu칞칚o direta para testes
    pytest.main([__file__, "-v", "--tb=short"]) 