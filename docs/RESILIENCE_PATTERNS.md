# üî• **GUIA DE PADR√ïES DE RESILI√äNCIA - OMNƒ∞ KEYWORDS FINDER**

**Tracing ID**: `RESILIENCE_PATTERNS_001_20250127`  
**Vers√£o**: 1.0  
**Data**: 2025-01-27  
**Status**: ‚úÖ **ATIVO**  
**Objetivo**: Documentar padr√µes de resili√™ncia implementados  

---

## üéØ **VIS√ÉO GERAL**

Este guia documenta os padr√µes de resili√™ncia implementados no sistema Omni Keywords Finder para garantir alta disponibilidade e toler√¢ncia a falhas.

### **üìä Padr√µes Implementados**
- Circuit Breaker Pattern
- Retry with Exponential Backoff
- Bulkhead Pattern
- Timeout Management
- Health Check Pattern
- Fallback Pattern

---

## üîå **CIRCUIT BREAKER PATTERN**

### **üìê Conceito**

O Circuit Breaker √© um padr√£o que previne falhas em cascata, monitorando o n√∫mero de falhas e "abrindo" o circuito quando o threshold √© atingido.

### **üèóÔ∏è Estados do Circuit Breaker**

```mermaid
stateDiagram-v2
    [*] --> CLOSED
    CLOSED --> OPEN : Falhas > threshold
    OPEN --> HALF_OPEN : Timeout expirado
    HALF_OPEN --> CLOSED : Sucesso
    HALF_OPEN --> OPEN : Falha
    CLOSED --> CLOSED : Sucesso
```

### **üîß Implementa√ß√£o**

```python
from infrastructure.resilience.circuit_breaker import CircuitBreaker

# Configura√ß√£o b√°sica
circuit_breaker = CircuitBreaker(
    failure_threshold=5,        # N√∫mero de falhas antes de abrir
    recovery_timeout=60,        # Tempo para tentar recuperar (segundos)
    expected_exception=Exception # Exce√ß√µes que contam como falha
)

# Uso com decorator
@circuit_breaker
def api_call():
    # Opera√ß√£o que pode falhar
    response = requests.get('https://api.example.com/data')
    response.raise_for_status()
    return response.json()

# Uso direto
try:
    result = circuit_breaker.call(api_call)
except CircuitBreakerOpenError:
    # Circuito aberto - usar fallback
    result = fallback_function()
```

### **üìä M√©tricas**

```python
# M√©tricas dispon√≠veis
metrics = {
    'failure_count': circuit_breaker.failure_count,
    'success_count': circuit_breaker.success_count,
    'state': circuit_breaker.state,
    'last_failure_time': circuit_breaker.last_failure_time,
    'failure_rate': circuit_breaker.failure_rate
}
```

### **üéØ Casos de Uso**

1. **APIs Externas**: Google Keyword Planner, YouTube API
2. **Database Operations**: Queries complexas
3. **Payment Gateways**: Stripe, PayPal
4. **File Operations**: Upload/Download

---

## üîÑ **RETRY WITH EXPONENTIAL BACKOFF**

### **üìê Conceito**

Padr√£o que implementa tentativas autom√°ticas com tempo de espera exponencial para recuperar de falhas tempor√°rias.

### **üìà Estrat√©gias de Backoff**

```mermaid
graph LR
    A[Tentativa 1] --> B[Espera 1s]
    B --> C[Tentativa 2] --> D[Espera 2s]
    D --> E[Tentativa 3] --> F[Espera 4s]
    F --> G[Tentativa 4] --> H[Espera 8s]
    H --> I[Falha Final]
```

### **üîß Implementa√ß√£o**

```python
from infrastructure.resilience.retry_decorator import retry_with_backoff

@retry_with_backoff(
    max_retries=3,           # M√°ximo de tentativas
    base_delay=1,            # Delay inicial (segundos)
    max_delay=60,            # Delay m√°ximo (segundos)
    exponential_base=2,      # Base exponencial
    jitter=True              # Adicionar varia√ß√£o aleat√≥ria
)
def api_call():
    response = requests.get('https://api.example.com/data')
    response.raise_for_status()
    return response.json()

# Configura√ß√£o avan√ßada
@retry_with_backoff(
    max_retries=5,
    base_delay=0.5,
    max_delay=30,
    exponential_base=2,
    jitter=True,
    retry_exceptions=(requests.RequestException,),
    backoff_exceptions=(requests.ConnectionError,)
)
def critical_api_call():
    # Opera√ß√£o cr√≠tica com retry espec√≠fico
    pass
```

### **üìä Estrat√©gias Dispon√≠veis**

1. **Exponential Backoff**: `delay = base_delay * (exponential_base ^ attempt)`
2. **Linear Backoff**: `delay = base_delay * attempt`
3. **Fixed Backoff**: `delay = base_delay`
4. **Fibonacci Backoff**: `delay = fibonacci(attempt)`

### **üéØ Casos de Uso**

1. **Network Requests**: APIs externas
2. **Database Connections**: Reconex√£o autom√°tica
3. **File Operations**: Tentativas de leitura/escrita
4. **Service Discovery**: Descoberta de servi√ßos

---

## üö™ **BULKHEAD PATTERN**

### **üìê Conceito**

O Bulkhead Pattern isola recursos e falhas entre diferentes partes do sistema, prevenindo que uma falha se propague.

### **üèóÔ∏è Arquitetura**

```mermaid
graph TB
    subgraph "Bulkhead A - API Calls"
        A1[API 1]
        A2[API 2]
        A3[API 3]
    end
    
    subgraph "Bulkhead B - Database"
        B1[Read Pool]
        B2[Write Pool]
        B3[Analytics Pool]
    end
    
    subgraph "Bulkhead C - File Operations"
        C1[Upload Pool]
        C2[Download Pool]
        C3[Processing Pool]
    end
    
    Client --> A1
    Client --> A2
    Client --> A3
    Client --> B1
    Client --> B2
    Client --> B3
    Client --> C1
    Client --> C2
    Client --> C3
```

### **üîß Implementa√ß√£o**

```python
from infrastructure.resilience.bulkhead import Bulkhead

# Bulkhead para opera√ß√µes de API
api_bulkhead = Bulkhead(
    max_concurrent_calls=10,    # M√°ximo de chamadas simult√¢neas
    max_wait_duration=30,       # Tempo m√°ximo de espera (segundos)
    name="api_operations"       # Nome para identifica√ß√£o
)

# Bulkhead para opera√ß√µes de banco
db_bulkhead = Bulkhead(
    max_concurrent_calls=5,
    max_wait_duration=60,
    name="database_operations"
)

@api_bulkhead
def call_external_api():
    # Opera√ß√£o isolada em seu pr√≥prio bulkhead
    pass

@db_bulkhead
def database_operation():
    # Opera√ß√£o de banco isolada
    pass
```

### **üìä Monitoramento**

```python
# M√©tricas do bulkhead
metrics = {
    'active_calls': bulkhead.active_calls,
    'max_concurrent_calls': bulkhead.max_concurrent_calls,
    'available_capacity': bulkhead.available_capacity,
    'rejected_calls': bulkhead.rejected_calls,
    'wait_time': bulkhead.average_wait_time
}
```

### **üéØ Casos de Uso**

1. **Microservices**: Isolamento entre servi√ßos
2. **Database Operations**: Separa√ß√£o de leitura/escrita
3. **External APIs**: Isolamento por provedor
4. **File Processing**: Separa√ß√£o por tipo de opera√ß√£o

---

## ‚è±Ô∏è **TIMEOUT MANAGEMENT**

### **üìê Conceito**

Gerenciamento de timeouts para evitar opera√ß√µes que ficam pendentes indefinidamente.

### **üîß Implementa√ß√£o**

```python
from infrastructure.resilience.timeout_decorator import timeout
from infrastructure.resilience.timeout_manager import TimeoutManager

# Timeout simples
@timeout(seconds=30)
def long_running_operation():
    # Opera√ß√£o com timeout de 30 segundos
    pass

# Timeout com contexto
timeout_manager = TimeoutManager()

with timeout_manager.timeout(seconds=60):
    # Opera√ß√£o com timeout de 60 segundos
    result = complex_operation()

# Timeout ass√≠ncrono
@timeout(seconds=30, async_timeout=True)
async def async_operation():
    # Opera√ß√£o ass√≠ncrona com timeout
    pass
```

### **üìä Tipos de Timeout**

1. **Connection Timeout**: Tempo para estabelecer conex√£o
2. **Read Timeout**: Tempo para ler resposta
3. **Write Timeout**: Tempo para enviar dados
4. **Total Timeout**: Tempo total da opera√ß√£o

### **üéØ Configura√ß√£o por Opera√ß√£o**

```python
# Configura√ß√µes espec√≠ficas
timeout_config = {
    'api_calls': 30,           # 30 segundos para APIs
    'database_queries': 10,    # 10 segundos para queries
    'file_operations': 120,    # 2 minutos para arquivos
    'batch_processing': 300    # 5 minutos para processamento
}
```

---

## üè• **HEALTH CHECK PATTERN**

### **üìê Conceito**

Monitoramento cont√≠nuo da sa√∫de dos componentes do sistema.

### **üîß Implementa√ß√£o**

```python
from infrastructure.health.advanced_health_check import AdvancedHealthCheck

# Health check para database
db_health_check = AdvancedHealthCheck(
    name="database",
    check_function=check_database_connection,
    interval=30,               # Verificar a cada 30 segundos
    timeout=10,                # Timeout de 10 segundos
    critical=True              # Cr√≠tico para o sistema
)

# Health check para API externa
api_health_check = AdvancedHealthCheck(
    name="external_api",
    check_function=check_api_availability,
    interval=60,               # Verificar a cada 1 minuto
    timeout=15,                # Timeout de 15 segundos
    critical=False             # N√£o cr√≠tico
)

# Registrando health checks
health_registry = HealthCheckRegistry()
health_registry.register(db_health_check)
health_registry.register(api_health_check)
```

### **üìä Tipos de Health Check**

1. **Liveness Check**: Verifica se o servi√ßo est√° vivo
2. **Readiness Check**: Verifica se o servi√ßo est√° pronto
3. **Startup Check**: Verifica se o servi√ßo inicializou corretamente
4. **Custom Check**: Verifica√ß√µes espec√≠ficas do neg√≥cio

### **üéØ Exemplos de Health Checks**

```python
def check_database_connection():
    """Verifica conex√£o com banco de dados."""
    try:
        db.execute("SELECT 1")
        return HealthStatus.HEALTHY
    except Exception as e:
        return HealthStatus.UNHEALTHY, str(e)

def check_redis_connection():
    """Verifica conex√£o com Redis."""
    try:
        redis.ping()
        return HealthStatus.HEALTHY
    except Exception as e:
        return HealthStatus.UNHEALTHY, str(e)

def check_external_api():
    """Verifica disponibilidade de API externa."""
    try:
        response = requests.get('https://api.example.com/health', timeout=5)
        if response.status_code == 200:
            return HealthStatus.HEALTHY
        else:
            return HealthStatus.UNHEALTHY, f"Status: {response.status_code}"
    except Exception as e:
        return HealthStatus.UNHEALTHY, str(e)
```

---

## üõ°Ô∏è **FALLBACK PATTERN**

### **üìê Conceito**

Estrat√©gia de fallback para quando o servi√ßo principal falha.

### **üîß Implementa√ß√£o**

```python
from infrastructure.resilience.fallback import FallbackStrategy

# Fallback simples
@FallbackStrategy(fallback_function=cache_fallback)
def get_data_from_api():
    # Tenta API principal
    return api_client.get_data()

def cache_fallback():
    # Fallback para cache
    return cache.get('data')

# Fallback com m√∫ltiplas op√ß√µes
@FallbackStrategy(
    fallbacks=[
        cache_fallback,
        database_fallback,
        static_fallback
    ]
)
def get_user_data(user_id):
    # Tenta m√∫ltiplas fontes
    return user_service.get_user(user_id)
```

### **üìä Estrat√©gias de Fallback**

1. **Cache Fallback**: Retorna dados do cache
2. **Database Fallback**: Retorna dados do banco
3. **Static Fallback**: Retorna dados est√°ticos
4. **Default Fallback**: Retorna valores padr√£o

---

## üîß **INTEGRA√á√ÉO DOS PADR√ïES**

### **üìê Exemplo Completo**

```python
from infrastructure.resilience import (
    CircuitBreaker, 
    retry_with_backoff, 
    Bulkhead, 
    timeout
)

# Configura√ß√£o completa
circuit_breaker = CircuitBreaker(failure_threshold=5, recovery_timeout=60)
bulkhead = Bulkhead(max_concurrent_calls=10, max_wait_duration=30)

@circuit_breaker
@retry_with_backoff(max_retries=3, base_delay=1)
@bulkhead
@timeout(seconds=30)
def robust_api_call():
    """Chamada de API com todos os padr√µes de resili√™ncia."""
    response = requests.get('https://api.example.com/data')
    response.raise_for_status()
    return response.json()
```

### **üìä Monitoramento Integrado**

```python
# M√©tricas combinadas
metrics = {
    'circuit_breaker': {
        'state': circuit_breaker.state,
        'failure_rate': circuit_breaker.failure_rate
    },
    'bulkhead': {
        'active_calls': bulkhead.active_calls,
        'available_capacity': bulkhead.available_capacity
    },
    'retry': {
        'total_attempts': retry_metrics.total_attempts,
        'successful_retries': retry_metrics.successful_retries
    }
}
```

---

## üìà **M√âTRICAS E ALERTAS**

### **üìä M√©tricas Principais**

1. **Circuit Breaker**:
   - Estado atual (CLOSED/OPEN/HALF_OPEN)
   - Taxa de falha
   - Tempo de recupera√ß√£o

2. **Retry Strategy**:
   - N√∫mero total de tentativas
   - Taxa de sucesso
   - Tempo m√©dio de retry

3. **Bulkhead**:
   - Chamadas ativas
   - Capacidade dispon√≠vel
   - Chamadas rejeitadas

4. **Timeout**:
   - Timeouts ocorridos
   - Tempo m√©dio de opera√ß√£o
   - Opera√ß√µes pendentes

### **üö® Alertas**

```yaml
# Prometheus Alert Rules
groups:
  - name: resilience_alerts
    rules:
      - alert: CircuitBreakerOpen
        expr: circuit_breaker_state == 1
        for: 1m
        labels:
          severity: warning
        annotations:
          summary: "Circuit breaker is open"
      
      - alert: HighRetryRate
        expr: retry_rate > 0.1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High retry rate detected"
      
      - alert: BulkheadFull
        expr: bulkhead_available_capacity == 0
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "Bulkhead is at full capacity"
```

---

## üß™ **TESTES DE RESILI√äNCIA**

### **üìê Testes de Circuit Breaker**

```python
def test_circuit_breaker_opens_on_failures():
    """Testa se o circuit breaker abre ap√≥s falhas."""
    cb = CircuitBreaker(failure_threshold=3)
    
    # Simula falhas
    for _ in range(3):
        with pytest.raises(Exception):
            cb.call(failing_function)
    
    # Verifica se o circuito est√° aberto
    assert cb.state == CircuitState.OPEN

def test_circuit_breaker_recovers():
    """Testa se o circuit breaker se recupera."""
    cb = CircuitBreaker(failure_threshold=2, recovery_timeout=1)
    
    # Abre o circuito
    for _ in range(2):
        with pytest.raises(Exception):
            cb.call(failing_function)
    
    # Aguarda recupera√ß√£o
    time.sleep(1.1)
    
    # Verifica se est√° em half-open
    assert cb.state == CircuitState.HALF_OPEN
```

### **üìê Testes de Retry**

```python
def test_retry_with_backoff():
    """Testa retry com backoff exponencial."""
    call_count = 0
    
    def failing_function():
        nonlocal call_count
        call_count += 1
        if call_count < 3:
            raise Exception("Temporary failure")
        return "success"
    
    result = retry_with_backoff(max_retries=3)(failing_function)()
    
    assert result == "success"
    assert call_count == 3
```

### **üìê Testes de Bulkhead**

```python
def test_bulkhead_limits_concurrency():
    """Testa se o bulkhead limita concorr√™ncia."""
    bulkhead = Bulkhead(max_concurrent_calls=2)
    active_calls = 0
    
    def slow_function():
        nonlocal active_calls
        active_calls += 1
        time.sleep(1)
        active_calls -= 1
    
    # Inicia 3 chamadas simult√¢neas
    threads = []
    for _ in range(3):
        thread = threading.Thread(target=lambda: bulkhead.call(slow_function))
        threads.append(thread)
        thread.start()
    
    # Verifica se apenas 2 est√£o ativas
    time.sleep(0.1)
    assert active_calls <= 2
```

---

## üìö **REFER√äNCIAS**

### **üìñ Livros**

- **Release It!**: Michael Nygard
- **Building Microservices**: Sam Newman
- **Site Reliability Engineering**: Google

### **üîó Artigos**

- [Circuit Breaker Pattern](https://martinfowler.com/bliki/CircuitBreaker.html)
- [Bulkhead Pattern](https://netflix.github.io/concurrency-limits/)
- [Retry Pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/retry)

### **üõ†Ô∏è Ferramentas**

- **Hystrix**: Netflix Circuit Breaker
- **Resilience4j**: Java resilience library
- **Polly**: .NET resilience library

---

## üìû **SUPORTE**

### **üë• Equipe**

- **DevOps**: devops@omni-keywords.com
- **SRE**: sre@omni-keywords.com
- **Engineering**: eng@omni-keywords.com

### **üìã Processo de Suporte**

1. **Identifica√ß√£o**: Detectar problema via alertas
2. **An√°lise**: Investigar m√©tricas e logs
3. **Corre√ß√£o**: Aplicar corre√ß√£o ou ajuste
4. **Valida√ß√£o**: Verificar se problema foi resolvido
5. **Documenta√ß√£o**: Registrar incidente e li√ß√µes aprendidas

---

**üìÖ √öltima Atualiza√ß√£o**: 2025-01-27  
**üìù Pr√≥xima Revis√£o**: 2025-02-27  
**üîó Vers√£o**: 1.0.0 